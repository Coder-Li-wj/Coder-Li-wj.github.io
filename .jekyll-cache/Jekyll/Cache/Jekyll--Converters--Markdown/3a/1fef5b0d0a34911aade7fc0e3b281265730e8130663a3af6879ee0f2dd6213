I"<h4 id="传统非模块化开发有如下缺点">传统非模块化开发有如下缺点：</h4>
<ol>
  <li>命名冲突</li>
  <li>文件依赖</li>
</ol>

<h4 id="前端标准的模块化规范">前端标准的模块化规范：</h4>
<ol>
  <li>AMD - requirejs</li>
  <li>CMD - seajs</li>
</ol>

<h4 id="服务器端的模块化规范">服务器端的模块化规范：</h4>
<ol>
  <li>CommonJs - Node.js</li>
</ol>

<p><strong>前端模块化规范和服务器端模块化规范的不同之处主要在：<code class="highlighter-rouge">文件加载</code>。<br />
对于前端的模块化：要加载js文件要从服务器端经过网络传输到浏览器端（一般是异步）；<br />
对于服务器端的模块化：js文件本来在服务器中，它的加载只需从磁盘加载到内存（同步）。</strong></p>

<h4 id="模块化相关的规则">模块化相关的规则：</h4>
<ol>
  <li>如何定义模块化：一个js文件就是一个模块化，模块内部的成员都是互相独立；</li>
  <li>模块成员的导出和引入：<br />
<strong>导出模块成员的两种方式：exports和module.exports，还有一个是global（不常用）</strong><br />
```javascript</li>
</ol>

<p>var sum = function(a, b){
    return parseInt(a) + parseInt(b)
}
// 导出模块成员
exports.sum = sum;</p>

<p>// 在另一个js文件中引入并使用
var module = require(‘路径’)//已经加载的模块会缓存，即使require多次也只有第一次有用
var result = module.sum(1 + 1)</p>

<p>// 方法二：module.exports
var sum = function(a, b){
    return parseInt(a) + parseInt(b)
}
// 导出模块成员
module.exports = sum;</p>

<p>// 在另一个js文件中引入并使用
var module = require(‘路径’)
var result = module(1 + 1)
```</p>

<h4 id="模块文件后缀的3中情况js-json-node">模块文件后缀的3中情况：.js .json .node</h4>
<p>不加文件后缀的情况下，以上三种模块的加载优先级：.js -&gt; .json -&gt; .node</p>
:ET